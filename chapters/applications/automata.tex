\documentclass{report}

\begin{document}
	Automaton is defined as a machine or control mechanism designed to automatically follow a predetermined sequence of operations, or respond to predetermined instructions. Theoretically, they all can be considered as the simplest form of algorithm, whether it is finite state automaton, push down automaton, or Turing machine. They all accept an input, and produce output; usually the output is $accept$ or $reject$, but in the case of Turing machines, the output may be something different.
	\section{Regular Language}
		\subsection{Deterministic Finite State Automaton}
			\begin{defn}[Deterministic Finite Automaton(DFA)] \label{def_DFA}
				A DFA $M$ is a 5-tuple, $(Q,\Sigma,\delta,q_0,F)$, consisting of:
				\begin{itemize}
					\item Finite set of states $Q$;
					\item Finite set of input symbols called the alphabet $\Sigma$;
					\item Transition function $\delta:Q \times \Sigma \rightarrow Q$;
					\item Initial state $q_0 \in Q$;
					\item Set of accepting states $F \subseteq Q$.
				\end{itemize}
			\end{defn}
		
		\subsection{Nondeterministic Finite Automaton}
			\begin{defn}[Nondeterministic Finite Automaton(NFA)] \label{def_NFA}
				A NFA $M$ is a 5-tuple, $(Q,\Sigma,\Delta,q_0,F)$, consisting of:
				\begin{itemize}
					\item Finite set of states $Q$;
					\item Finite set of input symbols called the alphabet $\Sigma$;
					\item Transition function $\Delta: Q \times \Sigma \rightarrow P(Q)$ where $P$ is the powerset function;
					\item Initial state $q_0 \in Q$;
					\item Set of accepting states $F \subseteq Q$.
				\end{itemize}
			\end{defn}
		
		\subsection{Regular Expression}
			\begin{defn}[Regular Expression(RE)] \label{def_RE}
				Given a finite alphabet $\Sigma$, the following constants are defined as regular expressions:
				\begin{itemize}
					\item \textbf{Empty set}: $\emptyset$, denoting the set $\emptyset$.
					\item \textbf{Empty string}: $\epsilon$, denoting the set containing only the "empty" string, which has no characters at all.
					\item \textbf{Literal character}: $a \in \Sigma$, denoting the only character $a$.
				\end{itemize}
				And when given regular expressions $R$ and $S$, the following operations over them produce regular expressions:
				\begin{itemize}
					\item \textbf{Concatenation}: $RS$, denoting the concatenation of strings in $R$ and $S$, in that order.
						\subitem $R^n$ denotes the concatenation of $R$, $n$ times: Specifically, $R^0=\{\epsilon\}$.
					\item \textbf{Alternation}: $R|S$, denoting the set union of the strings in $R$ and $S$.
					\item \textbf{Kleene star}: $R^*$, denoting $\bigcup_{i \in \mathbb{N}}R^i$.
				\end{itemize}
			\end{defn}
			
			\begin{defn}[Regular Languages] \label{def_RL}
				
			\end{defn}
			
			\begin{thm}[Pumping Lemma for Regular Languages] \label{thm_pumping_lemma_RL}
				
			\end{thm}
	
	\section{Context-Free Language}
		\subsection{Push-down Automaton}
			Similar to Finite Automatons, Push-down automatons have deterministic version and nondeterministic version; Only the nondeterministic version is shown here as similar method can be used to convert it into a deterministic version.
			\begin{defn}[Push-down Automaton(PDA)] \label{def_pda}
				A PDA is a 6-tuple $(Q,\Sigma,\Gamma,q_0,\Delta,F)$ where:
				\begin{itemize}
					\item $Q$ is the set of states;
					\item $\Sigma$ is the set of input alphabet;
					\item $\Gamma$ is the set of stack alphabet;
					\item $q_0$ is the starting state;
					\item $\Delta$ is the transition relation of $Q \times \Sigma_\epsilon \times \Gamma_\epsilon \times Q \times \Gamma_\epsilon$
					\item $F$ is the set of accepting states
				\end{itemize}
				$\Delta$ is often written as a transition function of $Q \times \Sigma_\epsilon \times \Gamma_\epsilon \times \rightarrow P(Q \times \Gamma_\epsilon)$ where $P$ is the powerset function.\\
				Sometimes the last element of the relation is extended to $\Gamma_\epsilon^*$; in that case, when inserting into the stack, insert the last element first.
			\end{defn}
		
		\subsection{Context-free Grammar}
			\begin{defn}[Context-Free Grammar(CFG)] \label{def_cfl}
				A CFL is a 4-tuple $(V,\Sigma,R,S)$ where:
				\begin{itemize}
					\item $V$ is the set of nonterminal variables;
					\item $\Sigma$ is the set of terminal characters;
					\item $R$ is the set of rules, where each rules are in the form of $A\rightarrow w, A\in V, w\in (\Sigma \cup V)^*$
					\item $S$ is the starting variable.
				\end{itemize}
			\end{defn}

			\begin{defn}[Context-free Languages] \label{def_CFL}
				
			\end{defn}

			\begin{thm}[Pumping Lemma for Context-free Languages] \label{thm_pumping_lemma_CFL}
				
			\end{thm}
		
			\begin{thm} \label{thm_cfl_pda_equivalence}
				Every CFL can be represented into an equivalent PDA.
			\end{thm}
		
			\begin{proof}
				Suppose a CFL $(V_0,\Sigma_0,R_0,S_0)$ is given.\\
				We can construct a new PDA $(Q,\Sigma,\Gamma,q_0,\Delta,F)$ from the given CFL s.t.
				\begin{itemize}
					\item $Q=\{Q_S,Q_M,Q_F\}$
					\item $\Sigma=\Sigma_0$
					\item $\Gamma=V_0 \cup \Sigma_0$
					\item $q_0=Q_S$
					\item $F=Q_F$
					\item $\Delta=$\\
					\begin{math}
					\{(Q_S,\epsilon,\epsilon,Q_M,S\$)\}\cup\\
					\{(Q_M,\epsilon,\epsilon,X,Q_M,W)|X->W \in R\}\cup\\
					\{(Q_M,a,a,Q_M,\epsilon)|a \in \Sigma_0\}\cup\\
					\{(Q_M,\epsilon,\$,Q_F,\epsilon)\}
					\end{math}
				\end{itemize}
				This exactly simulates the parse tree of the CFL.
			\end{proof}
	
	\section{Turing Machines}
		\begin{defn}[Turing Machine] \label{def_tm}
			A TM is a 7 tuple $(Q,\Sigma,\Gamma,\delta,q_0,q_{accept},q_{reject})$ where:
			\begin{itemize}
				\item $Q$ is the set of states;
				\item $\Sigma$ is the set of input alphabet;
				\item $\Gamma$ is the set of tape alphabet;
				\item $\delta$ is the transition function of $Q \times \gamma \rightarrow Q \times \gamma \times \{L,R\}$
				\item $q_0$ is the starting state
				\item $q_{accept}$ is the accepting state
				\item $q_{reject}$ is the rejecting state distinct from $q_{accept}$
			\end{itemize}
		\end{defn}
		The definition of a Turing Machine is not unique. Some definitions use multiple tapes, using one of them as the input tape that can't be modified and another as the output tape. Some has more than one halting states. Some include the "starting symbol" in the alphabet. Some include $N$ in the final output of the transition function. But in general, a Turing machine starts from one state, follows the decision function every step, and halts at the halting state. Some of the many variations on the Turing machine are mentioned in \ref{var_TM}.
		
		In fact, the different definitions of a Turing machine turns out to be the same, in the sense that a function $f:\strs \rightarrow \zo$ is computable using one definition of a Turing machine iff it is computable using another definition of a Turing Machine.
		
		We now give the following thesis from the creator of the $\lambda$-calculus, Alonzo Church and Alan Turing.
		\begin{thesis}[Church-Turing Thesis] \label{thm_church_turing}
			A function on Natural Numbers which is computable by a human being following an algorithm, ignoring resource limitations, if and only if it is computable by a Turing Machine.
		\end{thesis}
		
		\section{Decidable and Recognizable Languages}
		
		
		\section{Equivalences to Turing Machine}
			The followings can be shown to be equivalent to a Turing machine; however no proofs are given since they are usually long and arduous.
			\subsection{Push-down Automaton with Two Stacks}
			
			\subsection{Variations on the Turing Machine} \label{var_TM}
			
			\subsection{General Recursive Functions}
				\begin{defn}[General Recursive Functions] \label{def_general_recursive_function}
					General Recursive Functions, otherwise known as $\mu$-recursive functions, is a set of functions $\forall n \in \mathbb{N}, f:\mathbb{N}^n \rightarrow \mathbb{N}$ that includes the three "Initial", or "Basic" functions, and closed under three operators:
					\begin{itemize}
						\item Initial Functions
						\begin{itemize}
							\item \textbf{Constant Function:} $\forall n,k \in \mathbb{N}, f(x_1,\dots,x_k)=n$
								\subitem Alternative definition use a Zero function: $\forall k \in \mathbb{N}, Z(x_1,\dots,x_k)=0$
							\item \textbf{Successor Function $S$:} $S(x)=x+1$
							\item \textbf{Projection Function $P_i^k$:}
								\subitem This is also called the Identity Function $I_i^k$
						\end{itemize}
						\item Operators
						\begin{itemize}
							\item \textbf{Composition Operator $\circ$:} Given an m-ary function $h(x_1,\dots,x_m)$ and m k-ary functions $g_1(x_1,\dots,x_k),\dots,g_m(x_1,\dots,x_k)$:
							\begin{displaymath}
								h \circ (g_1,\dots,g_m)=f \text{   where   } f(x_1,\dots,x_k)=h(g_1(x_1,\dots,x_k),\dots,g_m(x_1,\dots,x_k))
							\end{displaymath}
								\subitem This is also called the Substitution Operator.
							\item \textbf{Primitive Recursion Operator $\rho$:} Given the k-ary function $g(x_1,\dots,x_k)$ and (k+2)-ary function $h(y,z,x_1,\dots,x_k)$:
							\begin{align*}
								\rho(g,h)&=f \text{   where}\\
								f(0,x_1,\dots,x_k)&=g(x_1,\dots,x_k)\\
								f(y+1,x_1,\dots,x_k)&=h(y,f(y,x_1,\dots,x_k),x_1,\dots,x_k)
							\end{align*}
							\item \textbf{Minimization Operator $\mu$:} Given a (k+1)-ary total function $f(y,x_1,\dots,x_k)$:
							\begin{align*}
								\mu (f)(x_1,\dots,x_k)=z \Leftrightarrow& f(z,x_1,\dots,x_k)=0 \text{   and}\\&f(i,x_1,\dots,x_k)>0 \text{   for   } i=0,\dots,z-1
							\end{align*}
								\subitem Intuitively, this operator seeks the smallest argument that causes the function to return 0; if none exists, the search never ends and therefore cannot return.
						\end{itemize}
					\end{itemize}
				\end{defn}
			
			\subsection{Lambda Calculus}
				Lambda Calculus, first defined by Alonzo Church, is a formal system of mathematical logic for expressing computation based on function-like objects.
				\begin{defn}[Lambda Expression] \label{def_lambda_expression}
					Lambda expressions are composed of:
					\begin{itemize}
						\item Variables, $v_1,\dots,v_n,\dots$
						\item The abstraction symbols lambda $\lambda$ and dot $.$
						\item Parentheses $( )$
					\end{itemize}
					For some applications, terms for logical and mathematical constants and operation may be included.
					
					The set of lambda expressions, $\Lambda$, can be defined inductively:
					\begin{itemize}
						\item If $x$ is a variable, then $x \in \Lambda$
						\item If $x$ is a variable and $M \in \Lambda$, then $(\lambda x.M)\in \Lambda$
							\subitem This rule is also known as Abstractions.
						\item If $M,N \in \Lambda$, then $(M N) \in \Lambda$
							\subitem This rule is also known as Application.
					\end{itemize}
				\end{defn}
				Though only the definition is given, \href{https://en.wikipedia.org/wiki/Lambda_calculus#Formal_definition}{This Wikipedia article} can be helpful to understand how lambda calculus works.
			
\end{document}